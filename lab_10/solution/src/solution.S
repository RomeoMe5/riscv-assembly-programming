.data
array: .dword 2, 4, 6, 8, 10  # Массив из 5 чисел (64-битные слова для RV64)
size: .dword 5                # Размер массива
multiplier: .dword 3          # Коэффициент умножения
buffer: .space 20             # Буфер для строки числа
newline: .asciz "\n"          # Символ новой строки

.text
.global main
main:
    # Сохраняем регистр возврата
    addi sp, sp, -16
    sd ra, 8(sp)

    # Инициализация
    la t0, array             # Указатель на начало массива
    ld t1, size              # Загрузка размера массива (64 бита)
    ld t2, multiplier        # Загрузка коэффициента умножения (64 бита)
    li t3, 0                 # Сумма
    li t4, 0                 # Счетчик цикла

    # Проверка на нулевой размер
    beqz t1, error_size_zero

multiply_loop:
    bge t4, t1, calculate_average  # Если обработали все элементы, переходим к вычислению среднего
    ld t5, 0(t0)                   # Загружаем текущий элемент массива (64 бита)
    mul t6, t5, t2                 # Умножаем элемент на коэффициент
    add t3, t3, t6                 # Добавляем результат к сумме
    addi t0, t0, 8                 # Сдвигаем указатель на следующий элемент (8 байт для RV64)
    addi t4, t4, 1                 # Увеличиваем счетчик
    j multiply_loop

calculate_average:
    div a0, t3, t1                 # Делим сумму на количество элементов
    jal number_to_string           # Преобразуем результат в строку
    jal print_string               # Выводим результат
    j end

error_size_zero:
    li a0, -1                      # Код ошибки: деление на ноль
    jal number_to_string           # Преобразуем -1 в строку
    jal print_string               # Выводим ошибку
    j end

# Преобразование числа в a0 в строку в buffer
number_to_string:
    la t0, buffer                # Указатель на буфер
    addi t0, t0, 19              # Конец буфера (записываем справа налево)
    sb zero, 0(t0)               # Завершающий нуль
    mv t1, a0                    # Число для преобразования
    li t2, 10                    # Основание системы счисления
    bgez t1, convert_loop        # Если число положительное, пропускаем знак
    li t3, '-'                   # Знак минус
    sb t3, -1(t0)                # Записываем минус
    addi t0, t0, -1
    neg t1, t1                   # Преобразуем в положительное

convert_loop:
    remu t3, t1, t2              # Остаток от деления на 10
    divu t1, t1, t2              # Делим на 10
    addi t3, t3, '0'             # Преобразуем цифру в символ
    addi t0, t0, -1              # Сдвигаем указатель
    sb t3, 0(t0)                 # Записываем символ
    bnez t1, convert_loop        # Продолжаем, если число не 0
    mv a0, t0                    # Указатель на начало строки
    ret

# Вывод строки из a0
print_string:
    mv t0, a0                    # Сохраняем указатель на строку
    li t1, 0                     # Длина строки
strlen_loop:
    lb t2, 0(t0)                 # Загружаем байт
    beqz t2, strlen_done         # Если нуль, конец строки
    addi t0, t0, 1               # Следующий байт
    addi t1, t1, 1               # Увеличиваем длину
    j strlen_loop
strlen_done:
    mv a2, t1                    # Длина строки
    mv a1, a0                    # Указатель на начало строки
    li a0, 1                     # Дескриптор stdout
    li a7, 64                    # Системный вызов write
    ecall                        # Вывод строки
    # Вывод новой строки
    li a0, 1                     # Дескриптор stdout
    la a1, newline               # Указатель на "\n"
    li a2, 1                     # Длина строки
    li a7, 64                    # Системный вызов write
    ecall
    ret

end:
    # Восстанавливаем регистр возврата
    ld ra, 8(sp)
    addi sp, sp, 16
    li a0, 0                     # Код возврата 0
    ret                          # Возврат для libc
